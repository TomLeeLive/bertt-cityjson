// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using CityJSON;
//
//    var cityJsonRoot = CityJsonRoot.FromJson(jsonString);

namespace CityJSON
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// CityJSON specifications v1.1.2
    /// </summary>
    public partial class CityJsonRoot
    {
        [JsonProperty("appearance", NullValueHandling = NullValueHandling.Ignore)]
        public Appearance Appearance { get; set; }

        [JsonProperty("CityObjects")]
        public Dictionary<string, CityObjectValue> CityObjects { get; set; }

        [JsonProperty("extensions", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, Extension> Extensions { get; set; }

        [JsonProperty("geometry-templates", NullValueHandling = NullValueHandling.Ignore)]
        public GeometryTemplates GeometryTemplates { get; set; }

        [JsonProperty("metadata", NullValueHandling = NullValueHandling.Ignore)]
        public Metadata Metadata { get; set; }

        [JsonProperty("transform")]
        public Transform Transform { get; set; }

        [JsonProperty("type")]
        public CityJsonRootType Type { get; set; }

        [JsonProperty("version")]
        public string Version { get; set; }

        [JsonProperty("vertices")]
        public double[][] Vertices { get; set; }
    }

    public partial class Appearance
    {
        [JsonProperty("default-theme-material", NullValueHandling = NullValueHandling.Ignore)]
        public string DefaultThemeMaterial { get; set; }

        [JsonProperty("default-theme-texture", NullValueHandling = NullValueHandling.Ignore)]
        public string DefaultThemeTexture { get; set; }

        [JsonProperty("materials", NullValueHandling = NullValueHandling.Ignore)]
        public MaterialElement[] Materials { get; set; }

        [JsonProperty("textures", NullValueHandling = NullValueHandling.Ignore)]
        public TextureElement[] Textures { get; set; }

        [JsonProperty("vertices-texture", NullValueHandling = NullValueHandling.Ignore)]
        public double[][] VerticesTexture { get; set; }
    }

    public partial class MaterialElement
    {
        [JsonProperty("ambientIntensity", NullValueHandling = NullValueHandling.Ignore)]
        public double? AmbientIntensity { get; set; }

        [JsonProperty("diffuseColor", NullValueHandling = NullValueHandling.Ignore)]
        public double[] DiffuseColor { get; set; }

        [JsonProperty("emissiveColor", NullValueHandling = NullValueHandling.Ignore)]
        public double[] EmissiveColor { get; set; }

        [JsonProperty("isSmooth", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsSmooth { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("shininess", NullValueHandling = NullValueHandling.Ignore)]
        public double? Shininess { get; set; }

        [JsonProperty("specularColor", NullValueHandling = NullValueHandling.Ignore)]
        public double[] SpecularColor { get; set; }

        [JsonProperty("transparency", NullValueHandling = NullValueHandling.Ignore)]
        public double? Transparency { get; set; }
    }

    public partial class TextureElement
    {
        [JsonProperty("borderColor", NullValueHandling = NullValueHandling.Ignore)]
        public double[] BorderColor { get; set; }

        [JsonProperty("image", NullValueHandling = NullValueHandling.Ignore)]
        public string Image { get; set; }

        [JsonProperty("textureType", NullValueHandling = NullValueHandling.Ignore)]
        public TextureTypeEnum? TextureType { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public TextureType? Type { get; set; }

        [JsonProperty("wrapMode", NullValueHandling = NullValueHandling.Ignore)]
        public WrapMode? WrapMode { get; set; }
    }

    public partial class CityObjectClass
    {
        [JsonProperty("attributes", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, object> Attributes { get; set; }

        /// <summary>
        /// the IDs of children
        /// </summary>
        [JsonProperty("children", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Children { get; set; }

        [JsonProperty("geographicalExtent", NullValueHandling = NullValueHandling.Ignore)]
        public double[] GeographicalExtent { get; set; }

        /// <summary>
        /// the IDs of the parents
        /// </summary>
        [JsonProperty("parents", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Parents { get; set; }

        /// <summary>
        /// the role of each of the CityObjects members of that group
        /// </summary>
        [JsonProperty("children_roles", NullValueHandling = NullValueHandling.Ignore)]
        public string[] ChildrenRoles { get; set; }

        [JsonProperty("geometry", NullValueHandling = NullValueHandling.Ignore)]
        public Geometry[] Geometry { get; set; }

        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("address", NullValueHandling = NullValueHandling.Ignore)]
        public Address[] Address { get; set; }
    }

    public partial class Address
    {
        [JsonProperty("location", NullValueHandling = NullValueHandling.Ignore)]
        public Location Location { get; set; }
    }

    public partial class Location
    {
        [JsonProperty("boundaries")]
        public long[] Boundaries { get; set; }

        [JsonProperty("lod")]
        public string Lod { get; set; }

        [JsonProperty("semantics", NullValueHandling = NullValueHandling.Ignore)]
        public LocationSemantics Semantics { get; set; }

        [JsonProperty("type")]
        public LocationType Type { get; set; }
    }

    public partial class LocationSemantics
    {
        [JsonProperty("surfaces")]
        public PurpleSurface[] Surfaces { get; set; }

        [JsonProperty("values")]
        public long?[] Values { get; set; }
    }

    public partial class PurpleSurface
    {
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }
    }

    public partial class Geometry
    {
        [JsonProperty("boundaries")]
        public GeometryBoundary[] Boundaries { get; set; }

        [JsonProperty("lod", NullValueHandling = NullValueHandling.Ignore)]
        public string Lod { get; set; }

        [JsonProperty("semantics", NullValueHandling = NullValueHandling.Ignore)]
        public GeometrySemantics Semantics { get; set; }

        [JsonProperty("type")]
        public GeometryType Type { get; set; }

        [JsonProperty("material", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, GeometryMaterial> Material { get; set; }

        [JsonProperty("texture", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, GeometryTexture> Texture { get; set; }

        [JsonProperty("template", NullValueHandling = NullValueHandling.Ignore)]
        public long? Template { get; set; }

        [JsonProperty("transformationMatrix", NullValueHandling = NullValueHandling.Ignore)]
        public double[] TransformationMatrix { get; set; }
    }

    public partial class GeometryMaterial
    {
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public long? Value { get; set; }

        [JsonProperty("values")]
        public object[] Values { get; set; }
    }

    public partial class GeometrySemantics
    {
        [JsonProperty("surfaces")]
        public FluffySurface[] Surfaces { get; set; }

        [JsonProperty("values")]
        public object[] Values { get; set; }
    }

    public partial class FluffySurface
    {
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }
    }

    public partial class GeometryTexture
    {
        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public MaterialValue[][][] Values { get; set; }
    }

    public partial class Extension
    {
        [JsonProperty("url")]
        public string Url { get; set; }

        [JsonProperty("version")]
        public string Version { get; set; }
    }

    public partial class GeometryTemplates
    {
        [JsonProperty("templates")]
        public Template[] Templates { get; set; }

        [JsonProperty("vertices-templates")]
        public double[][] VerticesTemplates { get; set; }
    }

    public partial class Template
    {
        [JsonProperty("boundaries")]
        public GeometryBoundary[] Boundaries { get; set; }

        [JsonProperty("lod")]
        public string Lod { get; set; }

        [JsonProperty("semantics", NullValueHandling = NullValueHandling.Ignore)]
        public TemplateSemantics Semantics { get; set; }

        [JsonProperty("type")]
        public TemplateType Type { get; set; }

        [JsonProperty("material", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, TemplateMaterial> Material { get; set; }

        [JsonProperty("texture", NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, TemplateTexture> Texture { get; set; }
    }

    public partial class TemplateMaterial
    {
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public long? Value { get; set; }

        [JsonProperty("values")]
        public object[] Values { get; set; }
    }

    public partial class TemplateSemantics
    {
        [JsonProperty("surfaces")]
        public TentacledSurface[] Surfaces { get; set; }

        [JsonProperty("values")]
        public object[] Values { get; set; }
    }

    public partial class TentacledSurface
    {
        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }
    }

    public partial class TemplateTexture
    {
        [JsonProperty("values", NullValueHandling = NullValueHandling.Ignore)]
        public MaterialValue[][][] Values { get; set; }
    }

    public partial class Metadata
    {
        [JsonProperty("geographicalExtent", NullValueHandling = NullValueHandling.Ignore)]
        public double[] GeographicalExtent { get; set; }

        [JsonProperty("identifier", NullValueHandling = NullValueHandling.Ignore)]
        public string Identifier { get; set; }

        [JsonProperty("pointOfContact", NullValueHandling = NullValueHandling.Ignore)]
        public PointOfContact PointOfContact { get; set; }

        [JsonProperty("referenceDate", NullValueHandling = NullValueHandling.Ignore)]
        public DateTimeOffset? ReferenceDate { get; set; }

        [JsonProperty("referenceSystem", NullValueHandling = NullValueHandling.Ignore)]
        public string ReferenceSystem { get; set; }

        [JsonProperty("title", NullValueHandling = NullValueHandling.Ignore)]
        public string Title { get; set; }
    }

    public partial class PointOfContact
    {
        [JsonProperty("address", NullValueHandling = NullValueHandling.Ignore)]
        public string Address { get; set; }

        [JsonProperty("contactName")]
        public string ContactName { get; set; }

        [JsonProperty("contactType", NullValueHandling = NullValueHandling.Ignore)]
        public ContactType? ContactType { get; set; }

        [JsonProperty("emailAddress")]
        public string EmailAddress { get; set; }

        [JsonProperty("organization", NullValueHandling = NullValueHandling.Ignore)]
        public string Organization { get; set; }

        [JsonProperty("phone", NullValueHandling = NullValueHandling.Ignore)]
        public string Phone { get; set; }

        /// <summary>
        /// from ISO 19115 codelist
        /// </summary>
        [JsonProperty("role", NullValueHandling = NullValueHandling.Ignore)]
        public Role? Role { get; set; }

        [JsonProperty("website", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Website { get; set; }
    }

    public partial class Transform
    {
        [JsonProperty("scale")]
        public double[] Scale { get; set; }

        [JsonProperty("translate")]
        public double[] Translate { get; set; }
    }

    public enum TextureTypeEnum { Specific, Typical, Unknown };

    public enum TextureType { Jpg, Png };

    public enum WrapMode { Border, Clamp, Mirror, None, Wrap };

    public enum LocationType { MultiPoint };

    public enum GeometryType { CompositeSolid, CompositeSurface, GeometryInstance, MultiLineString, MultiPoint, MultiSolid, MultiSurface, Solid };

    public enum TemplateType { CompositeSolid, CompositeSurface, MultiLineString, MultiPoint, MultiSolid, MultiSurface, Solid };

    public enum ContactType { Individual, Organization };

    /// <summary>
    /// from ISO 19115 codelist
    /// </summary>
    public enum Role { Author, CoAuthor, Collaborator, Contributor, Custodian, Distributor, Editor, Funder, Mediator, Originator, Owner, PointOfContact, PrincipalInvestigator, Processor, Publisher, ResourceProvider, RightsHolder, Sponsor, Stakeholder, User };

    public enum CityJsonRootType { CityJson };

    public partial struct PurpleBoundary
    {
        public long? Integer;
        public long[] IntegerArray;

        public static implicit operator PurpleBoundary(long Integer) => new PurpleBoundary { Integer = Integer };
        public static implicit operator PurpleBoundary(long[] IntegerArray) => new PurpleBoundary { IntegerArray = IntegerArray };
    }

    public partial struct FluffyBoundary
    {
        public PurpleBoundary[] AnythingArray;
        public long? Integer;

        public static implicit operator FluffyBoundary(PurpleBoundary[] AnythingArray) => new FluffyBoundary { AnythingArray = AnythingArray };
        public static implicit operator FluffyBoundary(long Integer) => new FluffyBoundary { Integer = Integer };
    }

    public partial struct TentacledBoundary
    {
        public FluffyBoundary[] AnythingArray;
        public long? Integer;

        public static implicit operator TentacledBoundary(FluffyBoundary[] AnythingArray) => new TentacledBoundary { AnythingArray = AnythingArray };
        public static implicit operator TentacledBoundary(long Integer) => new TentacledBoundary { Integer = Integer };
    }

    public partial struct GeometryBoundary
    {
        public TentacledBoundary[] AnythingArray;
        public long? Integer;

        public static implicit operator GeometryBoundary(TentacledBoundary[] AnythingArray) => new GeometryBoundary { AnythingArray = AnythingArray };
        public static implicit operator GeometryBoundary(long Integer) => new GeometryBoundary { Integer = Integer };
    }

    public partial struct ValueValue
    {
        public long? Integer;
        public long?[] UnionArray;

        public static implicit operator ValueValue(long Integer) => new ValueValue { Integer = Integer };
        public static implicit operator ValueValue(long?[] UnionArray) => new ValueValue { UnionArray = UnionArray };
        public bool IsNull => UnionArray == null && Integer == null;
    }

    public partial struct MaterialValue
    {
        public ValueValue[] AnythingArray;
        public long? Integer;

        public static implicit operator MaterialValue(ValueValue[] AnythingArray) => new MaterialValue { AnythingArray = AnythingArray };
        public static implicit operator MaterialValue(long Integer) => new MaterialValue { Integer = Integer };
        public bool IsNull => AnythingArray == null && Integer == null;
    }

    public partial struct CityObjectValue
    {
        public object[] AnythingArray;
        public bool? Bool;
        public CityObjectClass CityObjectClass;
        public double? Double;
        public long? Integer;
        public string String;

        public static implicit operator CityObjectValue(object[] AnythingArray) => new CityObjectValue { AnythingArray = AnythingArray };
        public static implicit operator CityObjectValue(bool Bool) => new CityObjectValue { Bool = Bool };
        public static implicit operator CityObjectValue(CityObjectClass CityObjectClass) => new CityObjectValue { CityObjectClass = CityObjectClass };
        public static implicit operator CityObjectValue(double Double) => new CityObjectValue { Double = Double };
        public static implicit operator CityObjectValue(long Integer) => new CityObjectValue { Integer = Integer };
        public static implicit operator CityObjectValue(string String) => new CityObjectValue { String = String };
        public bool IsNull => AnythingArray == null && Bool == null && CityObjectClass == null && Double == null && Integer == null && String == null;
    }

    public partial class CityJsonRoot
    {
        public static CityJsonRoot FromJson(string json) => JsonConvert.DeserializeObject<CityJsonRoot>(json, CityJSON.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this CityJsonRoot self) => JsonConvert.SerializeObject(self, CityJSON.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                CityObjectValueConverter.Singleton,
                LocationTypeConverter.Singleton,
                GeometryBoundaryConverter.Singleton,
                TentacledBoundaryConverter.Singleton,
                FluffyBoundaryConverter.Singleton,
                PurpleBoundaryConverter.Singleton,
                MaterialValueConverter.Singleton,
                ValueValueConverter.Singleton,
                GeometryTypeConverter.Singleton,
                TextureTypeEnumConverter.Singleton,
                TextureTypeConverter.Singleton,
                WrapModeConverter.Singleton,
                TemplateTypeConverter.Singleton,
                ContactTypeConverter.Singleton,
                RoleConverter.Singleton,
                CityJsonRootTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CityObjectValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CityObjectValue) || t == typeof(CityObjectValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new CityObjectValue { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new CityObjectValue { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new CityObjectValue { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new CityObjectValue { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new CityObjectValue { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<CityObjectClass>(reader);
                    return new CityObjectValue { CityObjectClass = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<object[]>(reader);
                    return new CityObjectValue { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type CityObjectValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (CityObjectValue)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            if (value.CityObjectClass != null)
            {
                serializer.Serialize(writer, value.CityObjectClass);
                return;
            }
            throw new Exception("Cannot marshal type CityObjectValue");
        }

        public static readonly CityObjectValueConverter Singleton = new CityObjectValueConverter();
    }

    internal class LocationTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LocationType) || t == typeof(LocationType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "MultiPoint")
            {
                return LocationType.MultiPoint;
            }
            throw new Exception("Cannot unmarshal type LocationType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LocationType)untypedValue;
            if (value == LocationType.MultiPoint)
            {
                serializer.Serialize(writer, "MultiPoint");
                return;
            }
            throw new Exception("Cannot marshal type LocationType");
        }

        public static readonly LocationTypeConverter Singleton = new LocationTypeConverter();
    }

    internal class GeometryBoundaryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GeometryBoundary) || t == typeof(GeometryBoundary?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new GeometryBoundary { Integer = integerValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<TentacledBoundary[]>(reader);
                    return new GeometryBoundary { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type GeometryBoundary");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (GeometryBoundary)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            throw new Exception("Cannot marshal type GeometryBoundary");
        }

        public static readonly GeometryBoundaryConverter Singleton = new GeometryBoundaryConverter();
    }

    internal class TentacledBoundaryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TentacledBoundary) || t == typeof(TentacledBoundary?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new TentacledBoundary { Integer = integerValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<FluffyBoundary[]>(reader);
                    return new TentacledBoundary { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type TentacledBoundary");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (TentacledBoundary)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            throw new Exception("Cannot marshal type TentacledBoundary");
        }

        public static readonly TentacledBoundaryConverter Singleton = new TentacledBoundaryConverter();
    }

    internal class FluffyBoundaryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FluffyBoundary) || t == typeof(FluffyBoundary?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new FluffyBoundary { Integer = integerValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<PurpleBoundary[]>(reader);
                    return new FluffyBoundary { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type FluffyBoundary");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (FluffyBoundary)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            throw new Exception("Cannot marshal type FluffyBoundary");
        }

        public static readonly FluffyBoundaryConverter Singleton = new FluffyBoundaryConverter();
    }

    internal class PurpleBoundaryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleBoundary) || t == typeof(PurpleBoundary?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new PurpleBoundary { Integer = integerValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<long[]>(reader);
                    return new PurpleBoundary { IntegerArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type PurpleBoundary");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (PurpleBoundary)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.IntegerArray != null)
            {
                serializer.Serialize(writer, value.IntegerArray);
                return;
            }
            throw new Exception("Cannot marshal type PurpleBoundary");
        }

        public static readonly PurpleBoundaryConverter Singleton = new PurpleBoundaryConverter();
    }

    internal class MaterialValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(MaterialValue) || t == typeof(MaterialValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new MaterialValue { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new MaterialValue { Integer = integerValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<ValueValue[]>(reader);
                    return new MaterialValue { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type MaterialValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (MaterialValue)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }
            throw new Exception("Cannot marshal type MaterialValue");
        }

        public static readonly MaterialValueConverter Singleton = new MaterialValueConverter();
    }

    internal class ValueValueConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ValueValue) || t == typeof(ValueValue?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Null:
                    return new ValueValue { };
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new ValueValue { Integer = integerValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<long?[]>(reader);
                    return new ValueValue { UnionArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type ValueValue");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (ValueValue)untypedValue;
            if (value.IsNull)
            {
                serializer.Serialize(writer, null);
                return;
            }
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.UnionArray != null)
            {
                serializer.Serialize(writer, value.UnionArray);
                return;
            }
            throw new Exception("Cannot marshal type ValueValue");
        }

        public static readonly ValueValueConverter Singleton = new ValueValueConverter();
    }

    internal class GeometryTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GeometryType) || t == typeof(GeometryType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CompositeSolid":
                    return GeometryType.CompositeSolid;
                case "CompositeSurface":
                    return GeometryType.CompositeSurface;
                case "GeometryInstance":
                    return GeometryType.GeometryInstance;
                case "MultiLineString":
                    return GeometryType.MultiLineString;
                case "MultiPoint":
                    return GeometryType.MultiPoint;
                case "MultiSolid":
                    return GeometryType.MultiSolid;
                case "MultiSurface":
                    return GeometryType.MultiSurface;
                case "Solid":
                    return GeometryType.Solid;
            }
            throw new Exception("Cannot unmarshal type GeometryType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GeometryType)untypedValue;
            switch (value)
            {
                case GeometryType.CompositeSolid:
                    serializer.Serialize(writer, "CompositeSolid");
                    return;
                case GeometryType.CompositeSurface:
                    serializer.Serialize(writer, "CompositeSurface");
                    return;
                case GeometryType.GeometryInstance:
                    serializer.Serialize(writer, "GeometryInstance");
                    return;
                case GeometryType.MultiLineString:
                    serializer.Serialize(writer, "MultiLineString");
                    return;
                case GeometryType.MultiPoint:
                    serializer.Serialize(writer, "MultiPoint");
                    return;
                case GeometryType.MultiSolid:
                    serializer.Serialize(writer, "MultiSolid");
                    return;
                case GeometryType.MultiSurface:
                    serializer.Serialize(writer, "MultiSurface");
                    return;
                case GeometryType.Solid:
                    serializer.Serialize(writer, "Solid");
                    return;
            }
            throw new Exception("Cannot marshal type GeometryType");
        }

        public static readonly GeometryTypeConverter Singleton = new GeometryTypeConverter();
    }

    internal class TextureTypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextureTypeEnum) || t == typeof(TextureTypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "specific":
                    return TextureTypeEnum.Specific;
                case "typical":
                    return TextureTypeEnum.Typical;
                case "unknown":
                    return TextureTypeEnum.Unknown;
            }
            throw new Exception("Cannot unmarshal type TextureTypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextureTypeEnum)untypedValue;
            switch (value)
            {
                case TextureTypeEnum.Specific:
                    serializer.Serialize(writer, "specific");
                    return;
                case TextureTypeEnum.Typical:
                    serializer.Serialize(writer, "typical");
                    return;
                case TextureTypeEnum.Unknown:
                    serializer.Serialize(writer, "unknown");
                    return;
            }
            throw new Exception("Cannot marshal type TextureTypeEnum");
        }

        public static readonly TextureTypeEnumConverter Singleton = new TextureTypeEnumConverter();
    }

    internal class TextureTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TextureType) || t == typeof(TextureType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "JPG":
                    return TextureType.Jpg;
                case "PNG":
                    return TextureType.Png;
            }
            throw new Exception("Cannot unmarshal type TextureType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TextureType)untypedValue;
            switch (value)
            {
                case TextureType.Jpg:
                    serializer.Serialize(writer, "JPG");
                    return;
                case TextureType.Png:
                    serializer.Serialize(writer, "PNG");
                    return;
            }
            throw new Exception("Cannot marshal type TextureType");
        }

        public static readonly TextureTypeConverter Singleton = new TextureTypeConverter();
    }

    internal class WrapModeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(WrapMode) || t == typeof(WrapMode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "border":
                    return WrapMode.Border;
                case "clamp":
                    return WrapMode.Clamp;
                case "mirror":
                    return WrapMode.Mirror;
                case "none":
                    return WrapMode.None;
                case "wrap":
                    return WrapMode.Wrap;
            }
            throw new Exception("Cannot unmarshal type WrapMode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (WrapMode)untypedValue;
            switch (value)
            {
                case WrapMode.Border:
                    serializer.Serialize(writer, "border");
                    return;
                case WrapMode.Clamp:
                    serializer.Serialize(writer, "clamp");
                    return;
                case WrapMode.Mirror:
                    serializer.Serialize(writer, "mirror");
                    return;
                case WrapMode.None:
                    serializer.Serialize(writer, "none");
                    return;
                case WrapMode.Wrap:
                    serializer.Serialize(writer, "wrap");
                    return;
            }
            throw new Exception("Cannot marshal type WrapMode");
        }

        public static readonly WrapModeConverter Singleton = new WrapModeConverter();
    }

    internal class TemplateTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TemplateType) || t == typeof(TemplateType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CompositeSolid":
                    return TemplateType.CompositeSolid;
                case "CompositeSurface":
                    return TemplateType.CompositeSurface;
                case "MultiLineString":
                    return TemplateType.MultiLineString;
                case "MultiPoint":
                    return TemplateType.MultiPoint;
                case "MultiSolid":
                    return TemplateType.MultiSolid;
                case "MultiSurface":
                    return TemplateType.MultiSurface;
                case "Solid":
                    return TemplateType.Solid;
            }
            throw new Exception("Cannot unmarshal type TemplateType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TemplateType)untypedValue;
            switch (value)
            {
                case TemplateType.CompositeSolid:
                    serializer.Serialize(writer, "CompositeSolid");
                    return;
                case TemplateType.CompositeSurface:
                    serializer.Serialize(writer, "CompositeSurface");
                    return;
                case TemplateType.MultiLineString:
                    serializer.Serialize(writer, "MultiLineString");
                    return;
                case TemplateType.MultiPoint:
                    serializer.Serialize(writer, "MultiPoint");
                    return;
                case TemplateType.MultiSolid:
                    serializer.Serialize(writer, "MultiSolid");
                    return;
                case TemplateType.MultiSurface:
                    serializer.Serialize(writer, "MultiSurface");
                    return;
                case TemplateType.Solid:
                    serializer.Serialize(writer, "Solid");
                    return;
            }
            throw new Exception("Cannot marshal type TemplateType");
        }

        public static readonly TemplateTypeConverter Singleton = new TemplateTypeConverter();
    }

    internal class ContactTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ContactType) || t == typeof(ContactType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "individual":
                    return ContactType.Individual;
                case "organization":
                    return ContactType.Organization;
            }
            throw new Exception("Cannot unmarshal type ContactType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ContactType)untypedValue;
            switch (value)
            {
                case ContactType.Individual:
                    serializer.Serialize(writer, "individual");
                    return;
                case ContactType.Organization:
                    serializer.Serialize(writer, "organization");
                    return;
            }
            throw new Exception("Cannot marshal type ContactType");
        }

        public static readonly ContactTypeConverter Singleton = new ContactTypeConverter();
    }

    internal class RoleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Role) || t == typeof(Role?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "author":
                    return Role.Author;
                case "co-author":
                    return Role.CoAuthor;
                case "collaborator":
                    return Role.Collaborator;
                case "contributor":
                    return Role.Contributor;
                case "custodian":
                    return Role.Custodian;
                case "distributor":
                    return Role.Distributor;
                case "editor":
                    return Role.Editor;
                case "funder":
                    return Role.Funder;
                case "mediator":
                    return Role.Mediator;
                case "originator":
                    return Role.Originator;
                case "owner":
                    return Role.Owner;
                case "pointOfContact":
                    return Role.PointOfContact;
                case "principalInvestigator":
                    return Role.PrincipalInvestigator;
                case "processor":
                    return Role.Processor;
                case "publisher":
                    return Role.Publisher;
                case "resourceProvider":
                    return Role.ResourceProvider;
                case "rightsHolder":
                    return Role.RightsHolder;
                case "sponsor":
                    return Role.Sponsor;
                case "stakeholder":
                    return Role.Stakeholder;
                case "user":
                    return Role.User;
            }
            throw new Exception("Cannot unmarshal type Role");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Role)untypedValue;
            switch (value)
            {
                case Role.Author:
                    serializer.Serialize(writer, "author");
                    return;
                case Role.CoAuthor:
                    serializer.Serialize(writer, "co-author");
                    return;
                case Role.Collaborator:
                    serializer.Serialize(writer, "collaborator");
                    return;
                case Role.Contributor:
                    serializer.Serialize(writer, "contributor");
                    return;
                case Role.Custodian:
                    serializer.Serialize(writer, "custodian");
                    return;
                case Role.Distributor:
                    serializer.Serialize(writer, "distributor");
                    return;
                case Role.Editor:
                    serializer.Serialize(writer, "editor");
                    return;
                case Role.Funder:
                    serializer.Serialize(writer, "funder");
                    return;
                case Role.Mediator:
                    serializer.Serialize(writer, "mediator");
                    return;
                case Role.Originator:
                    serializer.Serialize(writer, "originator");
                    return;
                case Role.Owner:
                    serializer.Serialize(writer, "owner");
                    return;
                case Role.PointOfContact:
                    serializer.Serialize(writer, "pointOfContact");
                    return;
                case Role.PrincipalInvestigator:
                    serializer.Serialize(writer, "principalInvestigator");
                    return;
                case Role.Processor:
                    serializer.Serialize(writer, "processor");
                    return;
                case Role.Publisher:
                    serializer.Serialize(writer, "publisher");
                    return;
                case Role.ResourceProvider:
                    serializer.Serialize(writer, "resourceProvider");
                    return;
                case Role.RightsHolder:
                    serializer.Serialize(writer, "rightsHolder");
                    return;
                case Role.Sponsor:
                    serializer.Serialize(writer, "sponsor");
                    return;
                case Role.Stakeholder:
                    serializer.Serialize(writer, "stakeholder");
                    return;
                case Role.User:
                    serializer.Serialize(writer, "user");
                    return;
            }
            throw new Exception("Cannot marshal type Role");
        }

        public static readonly RoleConverter Singleton = new RoleConverter();
    }

    internal class CityJsonRootTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CityJsonRootType) || t == typeof(CityJsonRootType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "CityJSON")
            {
                return CityJsonRootType.CityJson;
            }
            throw new Exception("Cannot unmarshal type CityJsonRootType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CityJsonRootType)untypedValue;
            if (value == CityJsonRootType.CityJson)
            {
                serializer.Serialize(writer, "CityJSON");
                return;
            }
            throw new Exception("Cannot marshal type CityJsonRootType");
        }

        public static readonly CityJsonRootTypeConverter Singleton = new CityJsonRootTypeConverter();
    }
}
